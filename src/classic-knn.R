# Classic k-nearest neighbor algorithms
loadData1 <- function() {
  data <- read.csv("data/eurusd60.csv",header=F,stringsAsFactors=F)
  colnames(data) <- c("date","time","open","high","low","close","volume")
  par(mfrow=c(1,1))
  plot(data$close,type="l")
}

loadData2 <- function() {
  t <- 1:1000
  data <- 10*sin(t/50*pi)
  par(mfrow=c(1,1))
  plot(data,type="l")
  return(data)
}

loadData3 <- function() {
  t <- 1:1000
  data <- as.numeric(arima.sim(list(ar=c(0.99),
                                    ma=c(0,0.5,-0.3)),n=1000))
  par(mfrow=c(1,1))
  plot(data,type="l")
  return(data)
}


kpredictn <- function(data,k,h,n.ahead,min.cor=0,
                      output=c("predicts","estimate","error")) {
  n <- length(data)
  series <- data[(n-h+1):n]
  range <- 1:(n-h-n.ahead+1)
  cors <- sapply(range,function(i) {
    pattern <- data[i:(i+h-1)]
    return(cor(pattern,series))
  })
  abs.cors <- abs(cors)
  orders <- order(abs.cors,decreasing=T)
  indices <- range[orders<=k & abs.cors>=min.cor]
  
  predicts <- t(sapply(indices,function(i) {
    pattern <- data[i:(i+h-1)]
    predictor <- data[(i+h):(i+h+n.ahead-1)]
    m <- rq(series~pattern)
    coeff <- coef(m)
    predictor <- coeff[[1]]+coeff[[2]]*predictor
    return(predictor)
  }))
  
  corsi <- cors[indices]
  abs.corsi <- abs(corsi)
  estimate <- sapply(1:n.ahead,function(t) {
    w <- exp(abs.corsi)
    sumw <- sum(w)
    preds <- w*predicts[,t]/sumw
    pred <- sum(preds)
    sd <- sd(preds)
    rsd <- sd/abs(pred)
    return(c(pred=pred,sd=sd,rsd=rsd))
  })
  error <- sum(estimate["sd",])
  result <- list(predicts=predicts,estimate=estimate,error=error)
  return(result[output])
}

kpredict <- function(data,hs,k,n.ahead=1,min.cor=0) {
  n <- length(data)
  g <- length(hs)
  groups <- 1:g
  plist <- lapply(hs,function(h) {
    predict <- kpredictn(data,h=h,k=k,n.ahead=n.ahead,min.cor=min.cor)
    result <- c(list(h=h),predict)
    return(result)
  })
  errors <- sapply(groups,function(i)plist[[i]]$error)
  orders <- order(errors)
  result <- plist[[groups[orders==1]]]
  return(list(errors=errors,orders=orders,pred=result))
}

# TODO: parallelize the method by passing functions as arguments
kvalidate <- function(data,start,hs,k,n.ahead,min.cor=0,print.out=T) {
  n <- length(data)
  range <- start:(n-n.ahead)
  valid <- sapply(range,function(i) {
    vdata <- data[1:i]
    result <- kpredict(vdata,hs=hs,k=k,n.ahead=n.ahead,min.cor=min.cor)
    pred <- result$pred$estimate["pred",]
    actual <- data[(i+1):(i+n.ahead)]
    residuals <- pred-actual
    mde <- mean(residuals)
    made <- mean(abs(residuals))
    cor <- cor(pred,actual)
    if(print.out) {
      print(i)
    }
    return(c(pred,actual=actual,mde=mde,made=made,cor=cor))
  })
  return(data.frame(t(valid)))
}

# Issues
# The predictor seems biased
# if the data is generated by arima, here we need a comparsion to arima fit
test <- function() {
  result <- kvalidate(data,500,
                      hs=seq(5,10),k=50,n.ahead=1,min.cor=0)
  par(mfrow=c(1,2))
  plot(density(result$mde),main="MDE")
  plot(density(result$made),main="MADE")
  par(mfrow=c(1,2))
  plot(result$pred,result$actual)
  plot(result$pred)
  lines(result$actual,col="red")
  return(result)
}